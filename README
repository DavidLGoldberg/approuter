This thing is designed to manage multiple versions of an application 
running simultaneously.  It will manage two types of running applications:
production and alternate.  

production - the 'in production' version of the application, this version
    will be managed as if it's presence were important and upgrades 
    to the underlying code (changes detected in the repo) will cause
    a graceful switch where the users should notice no downtime.

alternate - new 'in test' versions of the application.  Changes from the source
    repo for these applications are immediately applied with the existing version
    being forcibly replaced with the new.  The assumption here is that this 
    version is being worked on and you want your changes to be immediately
    available.

Other definitions

instance - a named instance of an application for example, the the case
    of having multiple alternate instances one might have alternate instances
    a, b, and c.  Production type applications only have two instances
    active and inactive.  

Routing amongst the application instances is managed by cookie, with the 
presence of the a type/instance cookie causing the request to be routed
to the correct type/instance.

Filesystem Structure

managed/ 
    This directory is where all the managed repos (applications) and the configuration
    data to manage them is stored.

managed/var
    This directory contains all the generated output from running the managed apps.  
    This includes: log files, config files, run data (pidfiles) etc.  It also includes
    the generated crontab that can be used to monitor the managed applications for 
    remote changes (from their repository as defined by the repo.conf).

etc/repo.conf
    Stores the repo url (git) that refers the the code managed by this instance of the
    approuter. This is the repository that contains the code that will be cloned into
    the production and alternate locations, and ultimately run.

etc/alternates.conf
    A list of branche names that will be run as alternates.  It is expected that the branches
    referenced already exist.

Controls

start / stop 
    These two do what you'd expect, starting and stopping the instances managed by the
    approuter along with nginx.

    Applications must be startable using an executable file in the root of the application
    named start, to which the first (and only) parameter passed will be the port to
    which the application should bind for incoming requests. The application will be
    started something like:
   
        pushd <app dir>
        ./start 3882

switch_nginx_config
    Toggles between the two running production instances, this switches out the configuration
    and HUPs nginx to make the switch seemless for connected users.

status
    Displays information about nginx and th running instances (think ps)

Usage
    - Edit the repo.conf, alternates.conf and starter.conf files according to the information
    given above.  
    - source the environment file in the root 
    - type start!
