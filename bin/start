#! /usr/bin/env bash
MY_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
source ${MY_DIR}/environment

ACTION=$1
shift

if [ "${ACTION}x" != "x" ]; then 
  # start can be passed the name of the service to start, or a convience indicator
  # like 'prod'
  if [ "${ACTION}" == "prod" ]; then
    perpctl U instance1
    perpctl U instance2
    exit 0
  else
    perpctl U ${ACTION}
    exit $?
  fi
fi

mkdir -p ${LOG_DIR}
mkdir -p ${RUN_DIR}

silent_pushd(){ pushd $1 > /dev/null 2>&1; }
silent_popd(){ popd $1 > /dev/null 2>&1 ; }

clone_repo_as_needed() {
    # $1 - the directory to check
    # $2 - the repository url
    # if there is no git repo in the directory provided
    # we'll go ahead and clone it
    mkdir -p $1
    PARENT_PATH=`dirname $1`
    DIRNAME=`basename $1`
    if [ ! -d ${1}/.git ]; then
        # no git, clone
        silent_pushd ${PARENT_PATH}
        git clone ${2} ${DIRNAME} 
        silent_popd
    else
        printf "repo found at $1, not cloning\n"
    fi
    # for our alternates.  the prod updater is a constant and
    # we'll be writing out our updater entires to a crontab
    # doesn't vary so we handle it elsewhere as a static entry
    if [ "`basename ${PARENT_PATH}`" = "alternates" ]; then
      echo "* * * * * ${MY_DIR}/restart_if_changed $1 > ${LOG_DIR}/restart_${DIRNAME}.log 2>&1" >> ${VAR_DIR}/crontab
    fi
}

setup_managed_repositories(){

    # two prod instances so we can roll
    clone_repo_as_needed ${MANAGED_ROOT}/prod/instance1 `cat ${REPO_CONF}`
    clone_repo_as_needed ${MANAGED_ROOT}/prod/instance2 `cat ${REPO_CONF}`
    # switch production branches if specified
    if [ -f ${PROD_BRANCH_CONF} ]; then
      PROD_BRANCH_NAME=`cat ${PROD_BRANCH_CONF}`
      pushd ${MANAGED_ROOT}/prod/instance1
      git checkout -b ${PROD_BRANCH_NAME} origin/${PROD_BRANCH_NAME}
      popd
      pushd ${MANAGED_ROOT}/prod/instance2
      git checkout -b ${PROD_BRANCH_NAME} origin/${PROD_BRANCH_NAME}
      popd
    fi
    
    # we want to get the name of our prod branch so we can use it to
    # determine where our environment settings will be stored (if there are
    # any).  Both prod instances will be on the same branch, or there's a problem
    pushd ${MANAGED_ROOT}/prod/instance1
    set_directory_branch_name
    PROD_BRANCH_NAME=${DIR_BRANCH_NAME}
    popd

    # alternates
    while read alternate
    do
        echo "initializing alternate ${alternate}"
        ALTERNATE_DIR=${ALTERNATES_ROOT}/${alternate}
        clone_repo_as_needed ${ALTERNATE_DIR} `cat ${REPO_CONF}`
        silent_pushd ${ALTERNATE_DIR}
        git checkout ${alternate}
        silent_popd
    done < ${ALTERNATES_CONF}
}

start_instance(){
    # $1 path to instance
    # $2 port
    set_instance_name_from_dir $1
    DIR_NAME=`basename $(dirname $1)`
    PORT=$2
    # everything must be able to be started with an executable named
    # start in the root of the directory that takes the first parameter
    # as the port on which it will listen
    START_CMD="./start ${PORT}"
    PIDFILE_NAME=${INSTANCE_NAME}_${2}.pid
    CTL_SFX=${INSTANCE_NAME}
    set_instance_start_control_file_path $1
    set_instance_stop_control_file_path $1

    #  if we're using an environment repo, or settings file will be found like
    #  the following ( within the environment repo )
    #  for prod:
    #     <repo name>/<prod branch>.env
    #  for the alternates:
    #     <repo name>/<prod branch>-<alt branch>.env
    if [ "${INSTANCE_NAME}" == "instance1" -o "${INSTANCE_NAME}" == "instance2" ]; then
      ENV_SETTINGS_FILE="${ENV_SETTINGS_REPO_DIR}/${REPOSITORY_NAME}/${PROD_BRANCH_NAME}.env"
    else
      ENV_SETTINGS_FILE="${ENV_SETTINGS_REPO_DIR}/${REPOSITORY_NAME}/${PROD_BRANCH_NAME}-${INSTANCE_NAME}.env"
    fi

    # write out control files for the instances we start
    echo "#! /usr/bin/env bash" > ${START_CTL_FILE}
    echo "perpctl -b ${PERP_BASE} U ${INSTANCE_NAME}" >> ${START_CTL_FILE}

    echo "#! /usr/bin/env bash" > ${STOP_CTL_FILE}
    echo "perpctl -b ${PERP_BASE} D ${INSTANCE_NAME}" >> ${STOP_CTL_FILE} 

    # this is the file we can call to block until the requested instance is
    # running and healthy, or times out
    cat ${TEMPLATE_DIR}/wait_for_service| \
      sed -e "s[\${1-perp_base}[${PERP_BASE}[g" |\
      sed -e "s[\${2-seconds_to_wait}[3[g" |\
      sed -e "s[\${3-instance_name}[${INSTANCE_NAME}[g"  > ${WAIT_FOR_START_FILE}

    # create our perp control files, and directory structure
    mkdir -p ${PERP_BASE}/${INSTANCE_NAME}
    cat ${TEMPLATE_DIR}/perp.rc.main | \
      sed -e "s[{{start_cmd}}[${START_CMD}[g" |\
      sed -e "s[{{env_settings_file}}[${ENV_SETTINGS_FILE}[g" |\
      sed -e s[{{change_to_dir}}[${1}[g  > ${PERP_BASE}/${INSTANCE_NAME}/rc.main
    cat ${TEMPLATE_DIR}/perp.rc.log | \
      sed -e "s[{{log_dir}}[${LOG_DIR}[g"  > ${PERP_BASE}/${INSTANCE_NAME}/rc.log

    chmod +x ${PERP_BASE}/${INSTANCE_NAME}/rc.*
    chmod +t ${PERP_BASE}/${INSTANCE_NAME}

    # keeping track of our running instance information so that we 
    # can build our nginx config
    printf "${DIR_NAME}\t${INSTANCE_NAME}\t${PORT}\n" >> ${RUN_DATA_FILE}
}

# cleanup our geneated files so we don't orphan anything and confuse people
rm -f ${VAR_DIR}/crontab
rm -f ${VAR_DIR}/run_data
rm -rf ${PERP_BASE}
rm -f ${RUNTIME_BIN_DIR}/*
rm -rf ${GENERATED_CONF_DIR}

REPOSITORY_URL=`cat ${REPO_CONF}`
REPOSITORY_NAME=`basename ${REPOSITORY_URL} | sed -e 's[\.git[[g'`
if [ -f ${ENV_SETTINGS_REPO_CONF} ]; then
  ENV_SETTINGS_REPO_URL=`cat ${ENV_SETTINGS_REPO_CONF}`
fi

# environment settings repo is optional, if we have one we will use it
if [ -n "${ENV_SETTINGS_REPO_URL}" ]; then
  pushd ${MANAGED_ROOT}
  if [ ! -d ${ENV_SETTINGS_REPO_DIR} ]; then
    git clone ${ENV_SETTINGS_REPO_URL} ${ENV_SETTINGS_REPO_DIR}
  else
    pushd ${ENV_SETTINGS_REPO_DIR}
    git pull
    git reset --hard origin/master
    popd
  fi
  popd
fi

echo "SHELL=/bin/bash" > ${VAR_DIR}/crontab
echo "PATH=${BUILD_ROOT}/bin:${BUILD_ROOT}/usr/sbin:${BUILD_ROOT}/sbin:${BUILD_ROOT}/usr/bin:/bin/:/usr/bin" >> ${VAR_DIR}/crontab

setup_managed_repositories;
# start each of our application instances
# prod ports will be 9051, 9052
start_instance ${MANAGED_ROOT}/prod/instance1 9051
start_instance ${MANAGED_ROOT}/prod/instance2 9052

# prod crontab, since it's a single entry and dosen't vary
echo "* * * * * cd ${ROOT} && source ./environment && ${MY_DIR}/update_prod_instance >> ${LOG_DIR}/update_prod.log 2>&1" >> ${VAR_DIR}/crontab
# alternates we'll start at 
PORT=10051
while read alternate_name
do
    PORT=`echo "${PORT}+1" | bc`
    ALTERNATE_DIR=${ALTERNATES_ROOT}/${alternate_name}
    start_instance ${ALTERNATE_DIR} ${PORT}
done < ${ALTERNATES_CONF}

# create our nginx config and link up our active one
$MY_DIR/gen_nginx_config

# always start with number one
# im not gonna force this one because the link should not exist
ln -s ${NGINX_CONF_FILE_1} ${NGINX_CONF_LINK}
if [ $? != 0 ]; then
  echo whoa, something is broken the nginx.conf link should not be there
  exit 1883
fi

# write out nginx control files
printf "#! /usr/bin/env bash\nperpctl U nginx" > ${RUNTIME_BIN_DIR}/start_nginx
printf "#! /usr/bin/env bash\nperpctl D nginx" > ${RUNTIME_BIN_DIR}/stop_nginx
# nginx for perpd
# create our perp control files, and directory structure
mkdir -p ${PERP_BASE}/nginx
cat ${TEMPLATE_DIR}/perp.rc.main | \
  sed -e "s[{{start_cmd}}[nginx -c ${NGINX_CONF_LINK}[g" |\
  sed -e s[{{change_to_dir}}[\.[g  > ${PERP_BASE}/nginx/rc.main
cat ${TEMPLATE_DIR}/perp.rc.log | \
  sed -e "s[{{log_dir}}[${LOG_DIR}[g"  > ${PERP_BASE}/nginx/rc.log

chmod +x ${PERP_BASE}/nginx/rc.*
# mark the perp service as being enabled
chmod +t ${PERP_BASE}/nginx

# generate our logrotate conf and crontab entry
sed -e s[{{log_dir}}[${LOG_DIR}[g ${LOGROTATE_CONF_TEMPLATE} > ${LOGROTATE_CONF}
echo "0 * * * *   source ${ROOT}/environment && logrotate --state ${VAR_DIR}/logrotate.state ${LOGROTATE_CONF}" >> ${VAR_DIR}/crontab

chmod +x ${RUNTIME_BIN_DIR}/*
perpd ${PERP_BASE} > ${LOG_DIR}/perpd.log 2>&1 &
for start_file in ${RUNTIME_BIN_DIR}/start*; 
do
  echo "starting ${start_file}"
  ${start_file}
done
if [ "${NO_CRONTAB_INSTALL}x" == "x" ]; then
  echo "installing crontab, just so you know..."
  crontab ${VAR_DIR}/crontab
fi
${MY_DIR}/status
