#! /usr/bin/env bash

MY_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
source ${MY_DIR}/environment

mkdir -p ${LOG_DIR}
mkdir -p ${RUN_DIR}

silent_pushd(){ pushd $1 > /dev/null 2>&1; }
silent_popd(){ popd $1 > /dev/null 2>&1 ; }

clone_repo_as_needed() {
    # $1 - the directory to check
    # $2 - the repository url
    # if there is no git repo in the directory provided
    # we'll go ahead and clone it
    mkdir -p $1
    PARENT_PATH=`dirname $1`
    DIRNAME=`basename $1`
    if [ ! -d ${1}/.git ]; then
        # no git, clone
        silent_pushd ${PARENT_PATH}
        git clone ${2} ${DIRNAME} 
        silent_popd
    else
        printf "repo found at $1, not cloning\n"
    fi
    # we'll be writing out our updater entires to a crontab
    # for our alternates.  the prod updater is a constant and
    # doesn't vary so we handle it elsewhere as a static entry
    if [ "`basename ${PARENT_PATH}`" = "alternates" ]; then
      echo "* * * * * ${MY_DIR}/restart_if_changed $1 > ${LOG_DIR}/restart_${DIRNAME}.log 2>&1" >> ${VAR_DIR}/crontab
    fi
}

setup_managed_repositories(){

    # two prod instances so we can roll
    clone_repo_as_needed ${MANAGED_ROOT}/prod/instance1 `cat ${REPO_CONF}`
    clone_repo_as_needed ${MANAGED_ROOT}/prod/instance2 `cat ${REPO_CONF}`

    # alternates
    while read alternate 
    do
        echo "initializing alternate ${alternate}"
        ALTERNATE_DIR=${ALTERNATES_ROOT}/${alternate}
        clone_repo_as_needed ${ALTERNATE_DIR} `cat ${REPO_CONF}`
        silent_pushd ${ALTERNATE_DIR}
        git checkout ${alternate}
        silent_popd
    done < ${ALTERNATES_CONF}
}

start_instance(){
    # $1 path to instance
    # $2 port
    set_instance_name_from_dir $1
    DIR_NAME=`basename $(dirname $1)`
    PORT=$2
    START_CMD=`echo "${START_CMD_TEMPLATE}" | sed -e s/{{port}}/${PORT}/g`
    PIDFILE_NAME=${INSTANCE_NAME}_${2}.pid
    CTL_SFX=${INSTANCE_NAME}
    set_instance_start_control_file_path $1
    set_instance_stop_control_file_path $1

    # write out control files for the instances we start
    echo "#! /usr/bin/env bash" > ${START_CTL_FILE}
    echo "perpctl -b ${PERP_BASE} u ${INSTANCE_NAME}" >> ${START_CTL_FILE}

    echo "#! /usr/bin/env bash" > ${STOP_CTL_FILE}
    echo "perpctl -b ${PERP_BASE} d ${INSTANCE_NAME}" >> ${STOP_CTL_FILE} 

    # create our perp control files, and directory structure
    mkdir -p ${PERP_BASE}/${INSTANCE_NAME}
    cat ${TEMPLATE_DIR}/perp.rc.main | \
      sed -e "s[{{start_cmd}}[${START_CMD}[g" |\
      sed -e s[{{change_to_dir}}[${1}[g  > ${PERP_BASE}/${INSTANCE_NAME}/rc.main
    cat ${TEMPLATE_DIR}/perp.rc.log | \
      sed -e "s[{{log_dir}}[${LOG_DIR}[g"  > ${PERP_BASE}/${INSTANCE_NAME}/rc.log

    chmod +x ${PERP_BASE}/${INSTANCE_NAME}/rc.*
    chmod +t ${PERP_BASE}/${INSTANCE_NAME}

    # keeping track of our running instance information so that we 
    # can build our nginx config
    printf "${DIR_NAME}\t${INSTANCE_NAME}\t${PORT}\n" >> ${RUN_DATA_FILE}
}

# cleanup our geneated files so we don't orphan anything and confuse people
rm -f ${VAR_DIR}/crontab
rm -f ${VAR_DIR}/run_data
rm -f ${RUNTIME_BIN_DIR}/*
rm -rf ${GENERATED_CONF_DIR}

echo "SHELL=/bin/bash" > ${VAR_DIR}/crontab
echo "PATH=${BUILD_ROOT}/bin:${BUILD_ROOT}/usr/sbin:${BUILD_ROOT}/sbin:${BUILD_ROOT}/usr/bin:/bin/:/usr/bin" >> ${VAR_DIR}/crontab

setup_managed_repositories;
# start each of our application instances
# prod ports will be 9001, 9002
start_instance ${MANAGED_ROOT}/prod/instance1 9001
start_instance ${MANAGED_ROOT}/prod/instance2 9002

# prod crontab, since it's a single entry and dose't vary
echo "* * * * * cd ${ROOT} && ${MY_DIR}/update_prod_instance > ${LOG_DIR}/update_prod.log 2>&1" >> ${VAR_DIR}/crontab
# alternates we'll start at 9050
PORT=9049
while read alternate_name
do
    PORT=`echo "${PORT}+1" | bc`
    ALTERNATE_DIR=${ALTERNATES_ROOT}/${alternate_name}
    start_instance ${ALTERNATE_DIR} ${PORT}
done < ${ALTERNATES_CONF}

# create our nginx config and link up our active one
$MY_DIR/gen_nginx_config

# always start with number one
# im not gonna force this one because the link should not exist
ln -s ${NGINX_CONF_FILE_1} ${NGINX_CONF_LINK}
if [ $? != 0 ]; then
  echo whoa, something is broken the nginx.conf link should not be there
  exit 1883
fi

# write out nginx control files
printf "#! /usr/bin/env bash\nperpctl u nginx" > ${RUNTIME_BIN_DIR}/start_nginx
printf "#! /usr/bin/env bash\nperpctl d nginx" > ${RUNTIME_BIN_DIR}/stop_nginx
# nginx for perps
# create our perp control files, and directory structure
mkdir -p ${PERP_BASE}/nginx
cat ${TEMPLATE_DIR}/perp.rc.main | \
  sed -e "s[{{start_cmd}}[nginx -c ${NGINX_CONF_LINK}[g" |\
  sed -e s[{{change_to_dir}}[\.[g  > ${PERP_BASE}/nginx/rc.main
cat ${TEMPLATE_DIR}/perp.rc.log | \
  sed -e "s[{{log_dir}}[${LOG_DIR}[g"  > ${PERP_BASE}/nginx/rc.log

chmod +x ${PERP_BASE}/nginx/rc.*
# mark the perp service as being enabled
chmod +t ${PERP_BASE}/nginx

# generate our logrotate conf and crontab entry
sed -e s[{{log_dir}}[${LOG_DIR}[g ${LOGROTATE_CONF_TEMPLATE} > ${LOGROTATE_CONF}
echo "0 * * * *   source ${ROOT}/environment && logrotate --state ${VAR_DIR}/logrotate.state ${LOGROTATE_CONF}" >> ${VAR_DIR}/crontab

chmod +x ${RUNTIME_BIN_DIR}/*
perpd ${PERP_BASE} > ${LOG_DIR}/perpd.log 2>&1 &
for start_file in ${RUNTIME_BIN_DIR}/start*; 
do
  echo "starting ${start_file}"
  ${start_file}
done
${MY_DIR}/status
