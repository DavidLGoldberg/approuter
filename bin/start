#! /usr/bin/env bash

MY_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
source ${MY_DIR}/environment

mkdir -p ${LOG_DIR}
mkdir -p ${RUN_DIR}

silent_pushd(){ pushd $1 > /dev/null 2>&1; }
silent_popd(){ popd $1 > /dev/null 2>&1 ; }

clone_repo_as_needed() {
    # $1 - the directory to check
    # $2 - the repository url
    # if there is no git repo in the directory provided
    # we'll go ahead and clone it
    mkdir -p $1
    PARENT_PATH=`dirname $1`
    DIRNAME=`basename $1`
    if [ ! -d ${1}/.git ]; then
        # no git, clone
        silent_pushd ${PARENT_PATH}
        git clone ${2} ${DIRNAME} 
        silent_popd
    else
        printf "repo found at $1, not cloning\n"
    fi
    # we'll be writing out our updater entires to a crontab
    # for our alternates.  the prod updater is a constant and
    # doesn't vary so we handle it elsewhere as a static entry
    if [ "`basename ${PARENT_PATH}`" = "alternates" ]; then
      echo "* * * * * ${MY_DIR}/restart_if_changed $1 > ${LOG_DIR}/restart_${DIRNAME}.log 2>&1" >> ${VAR_DIR}/crontab
    fi
}

setup_managed_repositories(){

    # two prod instances so we can roll
    clone_repo_as_needed ${MANAGED_ROOT}/prod/instance1 `cat ${REPO_CONF}`
    clone_repo_as_needed ${MANAGED_ROOT}/prod/instance2 `cat ${REPO_CONF}`

    # alternates
    while read alternate 
    do
        echo "initializing alternate ${alternate}"
        ALTERNATE_DIR=${ALTERNATES_ROOT}/${alternate}
        clone_repo_as_needed ${ALTERNATE_DIR} `cat ${REPO_CONF}`
        silent_pushd ${ALTERNATE_DIR}
        git checkout ${alternate}
        silent_popd
    done < ${ALTERNATES_CONF}
}

start_instance(){
    # $1 path to instance
    # $2 port
    set_instance_name_from_dir $1
    DIR_NAME=`basename $(dirname $1)`
    PORT=$2
    START_CMD=`echo "${START_CMD_TEMPLATE}" | sed -e s/{{port}}/${PORT}/g`
    START_CMD="${START_CMD}"
    PIDFILE_NAME=${INSTANCE_NAME}_${2}.pid
    CTL_SFX=${INSTANCE_NAME}
    set_instance_start_control_file_path $1
    set_instance_stop_control_file_path $1

    # write out control files for the instances we start
    echo "#! /usr/bin/env bash" > ${START_CTL_FILE}
    echo "pushd $1 > /dev/null 2>&1" >> ${START_CTL_FILE}
    echo "${START_CMD} > ${LOG_DIR}/${CTL_SFX}.log 2>&1 &" >> ${START_CTL_FILE}
    echo "INSTANCE_PID=\$!"  >> ${RUNTIME_BIN_DIR}/start_${CTL_SFX}
    echo "echo \${INSTANCE_PID} > ${RUN_DIR}/${PIDFILE_NAME}" >> ${START_CTL_FILE}
    echo "printf '#! /usr/bin/env bash\nkill \$(' > ${STOP_CTL_FILE}" >> ${START_CTL_FILE}
    echo "printf \"cat ${RUN_DIR}/${PIDFILE_NAME})\n\" >> ${STOP_CTL_FILE}" >> ${START_CTL_FILE}
    echo "printf \"[ \$\? == 0 ] && rm ${RUN_DIR}/${PIDFILE_NAME}\" >> ${STOP_CTL_FILE}" >> ${START_CTL_FILE}
    echo "chmod +x ${RUNTIME_BIN_DIR}/stop_${CTL_SFX}" >> ${START_CTL_FILE}
    echo "popd > /dev/null 2>&1" >> ${START_CTL_FILE}

    # keeping track of our running instance information so that we 
    # can build our nginx config
    printf "${DIR_NAME}\t${INSTANCE_NAME}\t${PORT}\n" >> ${RUN_DATA_FILE}
}

for pidfile in ${RUN_DIR}/*; 
do
    if [ -f $pidfile ]; then
        echo "looks like something may be running, fix that first"
        exit 1
    fi
done;

# cleanup our geneated files so we don't orphan anything and confuse people
rm -f ${VAR_DIR}/crontab
rm -f ${VAR_DIR}/run_data
rm -f ${RUNTIME_BIN_DIR}/*
rm -rf ${GENERATED_CONF_DIR}

setup_managed_repositories;
# start each of our application instances
# prod ports will be 9001, 9002
start_instance ${MANAGED_ROOT}/prod/instance1 9001
start_instance ${MANAGED_ROOT}/prod/instance2 9002

# prod crontab, since it's a single entry and dose't vary
echo "* * * * * ${MY_DIR}/update_prod_instance > ${LOG_DIR}/update_prod.log 2>&1" >> ${VAR_DIR}/crontab
# alternates we'll start at 9050
PORT=9049
while read alternate_name
do
    PORT=`echo "${PORT}+1" | bc`
    ALTERNATE_DIR=${ALTERNATES_ROOT}/${alternate_name}
    start_instance ${ALTERNATE_DIR} ${PORT}
done < ${ALTERNATES_CONF}

# create our nginx config and link up our active one
$MY_DIR/gen_nginx_config

# always start with number one
# im not gonna force this one because the link should not exist
ln -s ${NGINX_CONF_FILE_1} ${NGINX_CONF_LINK}
if [ $? != 0 ]; then
  echo whoa, something is broken the nginx.conf link should not be there
  exit 1883
fi

# write out nginx control files
printf "#! /usr/bin/env bash\nnginx -c ${NGINX_CONF_LINK}" > ${RUNTIME_BIN_DIR}/start_nginx
printf "#! /usr/bin/env bash\nnginx -c ${NGINX_CONF_LINK} -s quit" > ${RUNTIME_BIN_DIR}/stop_nginx

# generate our logrotate conf and crontab entry
sed -e s[{{log_dir}}[${LOG_DIR}[g ${LOGROTATE_CONF_TEMPLATE} > ${LOGROTATE_CONF}
echo "* 0 * * *   logrotate --state ${VAR_DIR}/logrotate.state ${LOGROTATE_CONF}" >> ${VAR_DIR}/crontab
chmod +x ${RUNTIME_BIN_DIR}/*
for start_file in ${RUNTIME_BIN_DIR}/start*; 
do
  echo "starting ${start_file}"
  ${start_file}
done
########${MY_DIR}/status
