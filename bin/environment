#! /usr/bin/env bash
silent_pushd(){ pushd $1 > /dev/null 2>&1; }
silent_popd(){ popd $1 > /dev/null 2>&1 ; }
log(){ echo "$@" >&2; }
debug() {
  if [ -n "${AR_DEBUG}" ]; then
    log "$@"
  fi
}

error(){ echo "ERROR: $@" >&2; }

bail_on_error(){
  ERROR_CODE=$?
  MESSAGE=$1
  if [ 0 -ne ${ERROR_CODE} ]; then
    if [ -n "${MESSAGE}" ]; then
      echo "Error (${ERROR_CODE}): ${MESSAGE}"
    fi
    exit ${ERROR_CODE}
  fi
}

debug "environment included from ${0}"

ROOT=${APPROUTER_ROOT}
MANAGED_ROOT=${ROOT}/managed
APPROUTER_BIN_DIR=${ROOT}/bin
BUILD_ROOT=${ROOT}/build_output
SBIN_DIR=${BUILD_ROOT}/sbin
USR_SBIN_DIR=${BUILD_ROOT}/usr/sbin
CONF_ROOT=${ROOT}/etc
HC_CONF=${CONF_ROOT}/health_check.conf
INSTANCE_GROUP_ROOT=${MANAGED_ROOT}/app_instances
ACTIVE_INSTANCE_LINK=${INSTANCE_GROUP_ROOT}/active
VAR_DIR=${MANAGED_ROOT}/var
NGINX_CACHE_DIR=${VAR_DIR}/cache/nginx
LOG_DIR=${VAR_DIR}/log
RUN_DIR=${VAR_DIR}/run
TEMP_DIR=${VAR_DIR}/temp
PERP_BASE=${MANAGED_ROOT}/etc/perp
RUNTIME_BIN_DIR=${VAR_DIR}/bin
GENERATED_CONF_DIR=${VAR_DIR}/conf
LOGROTATE_CONF_TEMPLATE=${ROOT}/templates/logrotate.conf
LOGROTATE_CONF=${GENERATED_CONF_DIR}/logrotate.conf
TEMPLATE_DIR=${ROOT}/templates
INSTANCE_DATE_FORMAT="%Y-%m-%dT%H_%M_%S%z"
INSTANCE_UPDATE_INTERVAL=60
INSTANCE_UPDATE_SERVICE_NAME=instance_update
LATEST_CONF=${CONF_ROOT}/latest
NGINX_PIDFILE=${RUN_DIR}/nginx.pid
NGINX_CONF_ROOT=${GENERATED_CONF_DIR}/nginx
NGINX_CONF_LINK=${GENERATED_CONF_DIR}/nginx/nginx.conf
NGINX_CONF_FILE=${GENERATED_CONF_DIR}/nginx/nginx.conf
NGINX_CONF_TEMPLATE=${ROOT}/templates/nginx.conf
TEMPLATE_OVERRIDE_ROOT=${CONF_ROOT}/overrides
APPLICATION_OVERLAY=${CONF_ROOT}/overrides/app_overlay

mkdir -p ${GENERATED_CONF_DIR}
mkdir -p ${INSTANCE_GROUP_ROOT}
mkdir -p ${NGINX_CONF_ROOT}
mkdir -p ${RUNTIME_BIN_DIR}
mkdir -p ${NGINX_CACHE_DIR}
mkdir -p ${TEMP_DIR}
mkdir -p ${PERP_BASE}
mkdir -p ${LOG_DIR}
mkdir -p ${RUN_DIR}
mkdir -p ${CONF_ROOT}

# conveniently we allow for storing off the last used configuration to allow
# for subsequent starts to be called without any parameters
# so if configuration data was not provided, we'll go ahead and load
# for clarity, we will use the saved configuration if it exists if any of
# the config values are missing (REPO_URL, NGINX_PORT, NUM_INSTANCES)
if [ -z "${REPO_URL}" -o -z "${NGINX_PORT}" -o -z "${NUM_INSTANCES}" ]; then
  debug "using saved configuration"
  if [ ! -e ${LATEST_CONF} ]; then
    log "unable to find configuration information"
    exit 11111
  fi
  source ${LATEST_CONF}
fi

if [ ${NUM_INSTANCES} -gt 50 ]; then
  # This limit is a fourth of the max services that perp will manage thus 50
  # would give us some room to upgrade and it's quite unlikely that anyone
  # would actually intend to have more than 50 services
  error "the max number of instances you can request is 50, you asked for ${NUM_INSTANCES}"
  exit 11112
fi
# save our settings for use in the future
echo "export REPO_URL=${REPO_URL? Missing REPO_URL, something is wrong}" > ${LATEST_CONF}
echo "export NGINX_PORT=${NGINX_PORT? Missing NGINX_PORT, something is wrong}" >> ${LATEST_CONF}
echo "export NUM_INSTANCES=${NUM_INSTANCES? Missing NUM_INSTANCES, something is wrong}" >> ${LATEST_CONF}

# we'll consider repo branch a non standard option, and only save it if present
# because there is a distinct difference between specifying a branch and not
if [ -n "${REPO_BRANCH}" ]; then
  echo "export REPO_BRANCH=${REPO_BRANCH}" >> ${LATEST_CONF}
fi

HEALTH_CHECK_PATH="/diagnostic"
if [ -f "${HC_CONF}" ]; then
  HEALTH_CHECK_PATH=`cat ${HC_CONF}`
fi

# template overrides, if present
if [ -f ${TEMPLATE_OVERRIDE_ROOT}/nginx.conf ]; then
  NGINX_CONF_TEMPLATE=${TEMPLATE_OVERRIDE_ROOT}/nginx.conf
fi
  


ENVIRONMENT_SOURCED=1
